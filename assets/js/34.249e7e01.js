(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{604:function(t,e,r){"use strict";r.r(e);var a=r(30),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"e-target-与-e-currenttarget-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#e-target-与-e-currenttarget-的区别"}},[t._v("#")]),t._v(" e.target 与 e.currentTarget 的区别")]),t._v(" "),r("blockquote",[r("p",[t._v("2018-10-24")])]),t._v(" "),r("p",[t._v("有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现"),r("code",[t._v("target")]),t._v("和"),r("code",[t._v("currentTarget")]),t._v("的区别我好像有些忘记了，垃圾 js，太多相似的 api 和属性了。")]),t._v(" "),r("p",[t._v("首先我们来看一下 MDN 上对它们的解释")]),t._v(" "),r("ul",[r("li",[t._v("target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。")]),t._v(" "),r("li",[t._v("currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。")])]),t._v(" "),r("p",[t._v("可能还是很抽象 ，这里提供一个在线"),r("a",{attrs:{href:"https://jsbin.com/xekebepaqi/edit?html,js,console,output",target:"_blank",rel:"noopener noreferrer"}},[t._v("demo"),r("OutboundLink")],1),t._v("。")]),t._v(" "),r("p",[t._v("也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。")])])}),[],!1,null,null,null);e.default=n.exports}}]);